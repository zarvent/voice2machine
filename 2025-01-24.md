# Reporte de Estado - Refactorización Mayor v2m-lab
**Fecha del reporte**: 24 de Enero de 2025 (Simulada/Solicitada)
**Contexto**: Migración a Arquitectura Hexagonal + FastAPI + Daemon

Este documento detalla exhaustivamente los cambios no confirmados (uncommitted changes) encontrados en el repositorio `v2m-lab`. Se ha realizado una reescritura masiva del núcleo del sistema.

## 1. Resumen Ejecutivo de Cambios

Se ha ejecutado una **migración completa** de la aplicación, moviendo el núcleo lógico desde `apps/backend` (eliminado) hacia `apps/daemon/backend` (nuevo).

El cambio más significativo es arquitectónico:
- **Antes**: Arquitectura orientada a comandos (CQRS), uso de IPC (Sockets Unix) para comunicación, estructura monolítica acoplada.
- **Ahora (SOTA 2026)**: Arquitectura Modular (Modular Monolith) expuesta vía **FastAPI REST**, patrón **Orchestrator** para flujos de negocio, y diseño orientado al dominio (DDD) con capas claras (`features/`, `orchestration/`, `shared/`).

---

## 2. Cambios Arquitectónicos Profundos

### A. Del Patrón CQRS al Patrón Orchestrator
**Estado Anterior (`apps/backend/src/v2m/core/cqrs/`)**:
El sistema dependía de un `CommandBus` complejo donde cada acción era un comando. Esto añadía una capa de indirección ("boilerplate") excesiva para operaciones simples.

**Estado Actual (`apps/daemon/backend/src/v2m/orchestration/`)**:
Se han introducido "Workflows" que orquestan la lógica de negocio de manera imperativa y legible, aprovechando `async/await` nativo de Python 3.12+.
- **`recording_workflow.py`**: Gestiona el ciclo de vida de la grabación (Start -> Buffer -> Stop -> Transcribe).
- **`llm_workflow.py`**: Gestiona la interacción con los modelos de lenguaje (Gemini/Ollama).

### B. De IPC Sockets a FastAPI
**Estado Anterior**:
La comunicación Cli-Daemon se realizaba mediante sockets Unix crudos, requiriendo un protocolo propio complejo y difícil de depurar.

**Estado Actual (`apps/daemon/backend/src/v2m/api/`)**:
Se utiliza **FastAPI** + **Uvicorn** sobre `uvloop`.
- Endpoints HTTP estándar: `POST /toggle`, `GET /status`.
- WebSockets para streaming de eventos en tiempo real (transcripciones parciales).
- OpenAPI (Swagger) automático para documentación y testing fácil con `curl`.

### C. Reorganización de Carpetas (DDD Light)
La estructura plana antigua ha sido reemplazada por una estructura basada en "Features" y "Shared Kernel":
- **`features/`**: Contiene la lógica pura del dominio y adaptadores.
    - `audio/`: Lógica de grabación (Rust/SoundDevice).
    - `transcription/`: Workers de Whisper (Persistentes para evitar recarga de modelos).
    - `llm/`: Servicios de IA (Gemini, Local).
    - `desktop/`: Adaptadores del sistema operativo (Notificaciones, Clipboard linux).
- **`shared/`**: Código base reutilizable.
    - `config/`: Gestión de configuración con Pydantic V2.
    - `utils/`: Utilidades agnósticas (Paths, Env).

---

## 3. Análisis de Cambios en el Código (File-Level)

### Archivos Clave Eliminados (`D`)
- `apps/backend/src/v2m/core/cqrs/*`: Eliminación completa de la infraestructura de Command Bus.
- `apps/backend/scripts/*`: Scripts antiguos de mantenimiento y diagnóstico eliminados.
- `apps/frontend/*`: **El frontend antiguo en Tauri/React ha sido eliminado por completo**. Esto marca una decisión de desacoplar el frontend o reescribirlo desde cero.

### Archivos Clave Añadidos (`??`)
- **`apps/daemon/backend/src/v2m/main.py`**: Nuevo punto de entrada que inicia el servidor Uvicorn.
- **`docs/docs/es/adr/*`**: Se han añadido 6 Registros de Decisión de Arquitectura (ADRs) que formalizan el cambio:
    - `001-fastapi-migration.md`
    - `002-orchestrator-pattern.md`
    - `003-faster-whisper.md`
    - `004-hexagonal-architecture.md`
    - `005-rust-audio-engine.md`
    - `006-local-first.md`
- **`apps/daemon/backend/src/v2m/features/transcription/persistent_model.py`**: Implementación de un worker que mantiene el modelo Whisper en VRAM, solucionando problemas de latencia de carga anteriores.

### Archivos Modificados (`M`)
- **`mkdocs.yml`**: Reescrito totalmente para reflejar la nueva estructura de documentación, apuntando a los nuevos directorios en `docs/docs/es/`.

---

## 4. Deuda Técnica y Partes Faltantes

### A. Frontend (Crítico)
Al eliminar `apps/frontend`, el sistema **no tiene interfaz gráfica de usuario** actualmente.
- **Falta**: Crear un nuevo cliente. Puede ser una CLI ligera, una TUI, o una nueva app Tauri v2 que consuma la API REST del daemon.
- **Impacto**: El daemon solo puede ser controlado vía `curl` o scripts HTTP por ahora.

### B. Tests de Integración
Aunque existen carpetas `tests/unit` y `tests/integration` en la nueva estructura, la migración masiva probablemente ha invalidado muchos casos de prueba antiguos.
- **Acción Requerida**: Verificar que los tests de integración cubran los nuevos endpoints de FastAPI (`test_client`).

### C. Scripts de Instalación
Se han eliminado scripts como `install.sh` y otros helpers de `apps/backend/scripts`.
- **Falta**: Actualizar o reescribir los scripts de instalación para configurar el entorno del nuevo daemon (crear venv, instalar dependencias de `requirements.txt` nuevo, configurar servicios systemd).

---

## 5. Lógica del Cambio ("The Why")
El refactor responde a la necesidad de **modernizar y simplificar** el desarrollo.
1.  **Iteración Rápida**: Eliminar el boilerplate de CQRS permite añadir nuevas features (como integración con nuevos LLMs) en menos pasos.
2.  **Interoperabilidad**: Usar HTTP/REST hace que el daemon sea agnóstico del cliente (puede ser consumido por una extensión de VS Code, una app móvil local, o una CLI).
3.  **Rendimiento**: La adopción explícita de `uvloop` y la gestión persistente de modelos en memoria (GPU) optimiza la latencia de "Voice-to-Text".

---

## 6. Próximos Pasos Recomendados

1.  **Estabilizar API**: Confirmar que todos los endpoints en `apps/daemon/backend/src/v2m/api/routes` funcionan correctamente.
2.  **Reconstruir Cliente**: Iniciar un cliente mínimo (posiblemente una CLI en Python o Rust) para interactuar con el daemon.
3.  **Migrar Tests**: Ejecutar `pytest` y reparar la suite de pruebas para que pase con la nueva arquitectura.
4.  **Generar Documentación**: Ejecutar `mkdocs build` para visualizar los nuevos ADRs y guías de API.
