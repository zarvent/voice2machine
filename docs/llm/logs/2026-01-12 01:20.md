# V2M Socket Race Condition Fix

## Problem
The toggle script reported `Error: Socket not found at /tmp/v2m_1000/v2m.sock` even though the daemon was running and listening on [/run/user/1000/v2m/v2m.sock](file:///run/user/1000/v2m/v2m.sock).

## Root Causes Fixed

### 1. Path Discovery Bug in [send_command.py](file:///home/zarvent/developer/v2m-lab/scripts/utils/send_command.py)
The client only returned the XDG path if the socket **already existed**, falling back to the wrong `/tmp` path:

```diff:send_command.py
#!/usr/bin/env python3
"""
Standalone IPC client for voice2machine.
Designed to minimize startup latency for keyboard shortcuts.
"""

import sys
import socket
import json
import os
import struct

def get_socket_path():
    """Discover socket path using XDG standard or default fallback."""
    # 1. Check environment variable
    if "V2M_SOCKET_PATH" in os.environ:
        return os.environ["V2M_SOCKET_PATH"]

    # 2. Check XDG_RUNTIME_DIR
    xdg_runtime = os.environ.get("XDG_RUNTIME_DIR")
    if xdg_runtime:
        path = os.path.join(xdg_runtime, "v2m", "v2m.sock")
        if os.path.exists(path):
            return path

    # 3. Fallback to /tmp
    uid = os.getuid()
    path = f"/tmp/v2m_{uid}/v2m.sock"
    return path

def send_command(cmd, payload=None):
    socket_path = get_socket_path()

    if not os.path.exists(socket_path):
        # Print error in JSON format so caller can parse it if needed, or just stderr
        print(f"Error: Socket not found at {socket_path}", file=sys.stderr)
        sys.exit(1)

    try:
        # Create socket
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.connect(socket_path)

        # Prepare request
        request = {"cmd": cmd, "data": payload}
        msg_bytes = json.dumps(request).encode("utf-8")

        # Send (4-byte length prefix + payload)
        sock.sendall(struct.pack(">I", len(msg_bytes)))
        sock.sendall(msg_bytes)

        # Receive header (4-byte length)
        header = sock.recv(4)
        if not header:
            print("Error: Incomplete response (no header)", file=sys.stderr)
            sys.exit(1)

        resp_len = struct.unpack(">I", header)[0]

        # Receive body
        resp_data = b""
        while len(resp_data) < resp_len:
            chunk = sock.recv(resp_len - len(resp_data))
            if not chunk:
                break
            resp_data += chunk

        sock.close()

        # Print raw JSON response for the shell script to parse
        print(resp_data.decode("utf-8"))

    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: send_command.py <COMMAND> [PAYLOAD_JSON]", file=sys.stderr)
        sys.exit(1)

    cmd = sys.argv[1]
    payload = None
    if len(sys.argv) > 2:
        try:
            payload = json.loads(sys.argv[2])
        except json.JSONDecodeError:
            # If not JSON, treat as raw text for convenience (e.g. PROCESS_TEXT "some text")
            payload = {"text": " ".join(sys.argv[2:])}

    send_command(cmd, payload)
===
#!/usr/bin/env python3
"""
Standalone IPC client for voice2machine.
Designed to minimize startup latency for keyboard shortcuts.
"""

import sys
import socket
import json
import os
import struct

def get_socket_path():
    """Discover socket path using XDG standard or default fallback."""
    # 1. Check environment variable
    if "V2M_SOCKET_PATH" in os.environ:
        return os.environ["V2M_SOCKET_PATH"]

    # 2. Check XDG_RUNTIME_DIR (always prefer, same logic as daemon)
    xdg_runtime = os.environ.get("XDG_RUNTIME_DIR")
    if xdg_runtime:
        return os.path.join(xdg_runtime, "v2m", "v2m.sock")

    # 3. Fallback to /tmp
    uid = os.getuid()
    path = f"/tmp/v2m_{uid}/v2m.sock"
    return path

def send_command(cmd, payload=None):
    socket_path = get_socket_path()

    if not os.path.exists(socket_path):
        # Print error in JSON format so caller can parse it if needed, or just stderr
        print(f"Error: Socket not found at {socket_path}", file=sys.stderr)
        sys.exit(1)

    try:
        # Create socket
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.connect(socket_path)

        # Prepare request
        request = {"cmd": cmd, "data": payload}
        msg_bytes = json.dumps(request).encode("utf-8")

        # Send (4-byte length prefix + payload)
        sock.sendall(struct.pack(">I", len(msg_bytes)))
        sock.sendall(msg_bytes)

        # Receive header (4-byte length)
        header = sock.recv(4)
        if not header:
            print("Error: Incomplete response (no header)", file=sys.stderr)
            sys.exit(1)

        resp_len = struct.unpack(">I", header)[0]

        # Receive body
        resp_data = b""
        while len(resp_data) < resp_len:
            chunk = sock.recv(resp_len - len(resp_data))
            if not chunk:
                break
            resp_data += chunk

        sock.close()

        # Print raw JSON response for the shell script to parse
        print(resp_data.decode("utf-8"))

    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: send_command.py <COMMAND> [PAYLOAD_JSON]", file=sys.stderr)
        sys.exit(1)

    cmd = sys.argv[1]
    payload = None
    if len(sys.argv) > 2:
        try:
            payload = json.loads(sys.argv[2])
        except json.JSONDecodeError:
            # If not JSON, treat as raw text for convenience (e.g. PROCESS_TEXT "some text")
            payload = {"text": " ".join(sys.argv[2:])}

    send_command(cmd, payload)
```

---

### 2. Insufficient Startup Wait Time
Shell scripts waited only 2 seconds, but Whisper model loading takes ~5-6 seconds. Added socket-ready polling:

```diff:v2m-daemon.sh
#!/bin/bash

# This file is part of voice2machine.
#
# voice2machine is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# voice2machine is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with voice2machine.  If not, see <https://www.gnu.org/licenses/>.
#
# v2m-daemon.sh - script para gestionar el servicio voice2machine
#
# DESCRIPCI√ìN
#   este script te permite controlar el servicio de v2m que se ejecuta
#   en segundo plano puedes iniciarlo detenerlo reiniciarlo y
#   verificar si todo est√° funcionando bien
#
# USO
#   ./scripts/v2m-daemon.sh [start|stop|restart|status|logs]
#
# COMANDOS
#   start    - inicia el servicio en segundo plano
#   stop     - detiene el servicio de forma segura
#   restart  - reinicia el servicio primero lo detiene y luego lo inicia
#   status   - te muestra el estado actual y prueba la conexi√≥n
#   logs     - te muestra los registros del servicio
#
# ARCHIVOS
#   /tmp/v2m_daemon.log  - archivo donde se guardan los registros
#   /tmp/v2m_daemon.pid  - archivo que guarda el identificador del proceso
#
# VARIABLES DE ENTORNO
#   LD_LIBRARY_PATH - se configura sola para que funcione con cuda
#   PYTHONPATH      - se configura para incluir el c√≥digo fuente
#
# DEPENDENCIAS
#   - python 3.12+ con entorno virtual en ./venv
#   - librer√≠as de nvidia en el entorno virtual opcional para gpu
#
# EJEMPLOS
#   # iniciar el servicio
#   ./scripts/v2m-daemon.sh start
#
#   # ver c√≥mo est√° todo y probar la conexi√≥n
#   ./scripts/v2m-daemon.sh status
#
#   # ver qu√© est√° pasando en tiempo real
#   ./scripts/v2m-daemon.sh logs
#
# NOTAS
#   - el servicio usa un socket unix para comunicarse
#   - los registros se limpian solos autom√°ticamente
#   - si no tienes tarjeta gr√°fica nvidia usar√° el procesador autom√°ticamente
#
# AUTOR
#   equipo voice2machine
#
# DESDE
#   v1.0.0
#

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
PROJECT_DIR="$( dirname "$( dirname "${SCRIPT_DIR}" )" )/apps/backend"
VENV_PYTHON="${PROJECT_DIR}/venv/bin/python"

# --- LOAD COMMON UTILS ---
source "${SCRIPT_DIR}/../utils/common.sh"
RUNTIME_DIR=$(get_runtime_dir)
LOG_FILE="${RUNTIME_DIR}/v2m_daemon.log"
PID_FILE="${RUNTIME_DIR}/v2m_daemon.pid"

start_daemon() {
    if [ -f "${PID_FILE}" ]; then
        PID=$(cat "${PID_FILE}")
        if ps -p "${PID}" > /dev/null 2>&1; then
            echo "‚ùå el servicio ya est√° corriendo (pid: ${PID})"
            return 1
        else
            echo "‚ö†Ô∏è  encontr√© un archivo pid pero el proceso no existe as√≠ que voy a limpiarlo"
            rm -f "${PID_FILE}"
        fi
    fi

    echo "üöÄ iniciando el servicio de v2m..."

    cd "${PROJECT_DIR}"
    export PYTHONPATH="${PROJECT_DIR}/src"

    # --- configurar ld_library_path para cuda y cudnn ---
    # buscamos las librer√≠as de nvidia en el entorno virtual que son
    # necesarias para que whisper funcione con la tarjeta gr√°fica

    # 1. Try to find site-packages dir directly
    VENV_LIB_BASE="${PROJECT_DIR}/venv/lib"
    # Find the first python3.x dir (usually only one)
    PYTHON_LIB_DIR=$(find "$VENV_LIB_BASE" -maxdepth 1 -name "python3.*" -type d | head -n 1)

    if [ -n "$PYTHON_LIB_DIR" ]; then
        VENV_LIB="${PYTHON_LIB_DIR}/site-packages/nvidia"
        CUDA_PATHS=""

        if [ -d "${VENV_LIB}" ]; then
            for lib_path in "${VENV_LIB}"/*/lib; do
                if [ -d "$lib_path" ]; then
                    if [ -z "${CUDA_PATHS}" ]; then
                        CUDA_PATHS="$lib_path"
                    else
                        CUDA_PATHS="${CUDA_PATHS}:${lib_path}"
                    fi
                fi
            done
        fi

        # agregamos las rutas a la variable de entorno
        if [ -n "${CUDA_PATHS}" ]; then
            export LD_LIBRARY_PATH="${CUDA_PATHS}:${LD_LIBRARY_PATH:-}"
            echo "üîß configur√© las librer√≠as de nvidia para usar la tarjeta gr√°fica"
        else
            echo "‚ö†Ô∏è  no encontr√© las librer√≠as de nvidia"
        fi
    fi

    "${VENV_PYTHON}" -m v2m.main --daemon > "${LOG_FILE}" 2>&1 &

    DAEMON_PID=$!
    echo "${DAEMON_PID}" > "${PID_FILE}"

    # esperamos un momento para asegurarnos de que arranc√≥ bien
    sleep 2

    if ps -p "${DAEMON_PID}" > /dev/null 2>&1; then
        echo "‚úÖ el servicio arranc√≥ correctamente (pid: ${DAEMON_PID})"
        echo "üìã puedes ver los registros en: ${LOG_FILE}"
    else
        echo "‚ùå hubo un problema al iniciar el servicio revisa los registros"
        tail -20 "${LOG_FILE}"
        rm -f "${PID_FILE}"
        return 1
    fi
}

stop_daemon() {
    if [ ! -f "${PID_FILE}" ]; then
        echo "‚ö†Ô∏è  no encontr√© el archivo pid as√≠ que buscar√© el proceso manualmente"
        PID=$(ps aux | grep "python.*v2m.main --daemon" | grep -v grep | awk '{print $2}' | head -1)
        if [ -z "${PID}" ]; then
            echo "‚ùå el servicio no est√° corriendo"
            return 1
        fi
    else
        PID=$(cat "${PID_FILE}")
    fi

    echo "üõë deteniendo el servicio (pid: ${PID})..."
    kill -TERM "${PID}" 2>/dev/null

    # esperamos hasta 5 segundos para que termine ordenadamente
    for i in {1..10}; do
        if ! ps -p "${PID}" > /dev/null 2>&1; then
            echo "‚úÖ servicio detenido correctamente"
            rm -f "${PID_FILE}"
            return 0
        fi
        sleep 0.5
    done

    # si no termin√≥ lo forzamos
    echo "‚ö†Ô∏è  el servicio no respondi√≥ as√≠ que lo voy a forzar"
    kill -9 "${PID}" 2>/dev/null
    rm -f "${PID_FILE}"
    echo "‚úÖ servicio detenido forzadamente"
}

status_daemon() {
    if [ -f "${PID_FILE}" ]; then
        PID=$(cat "${PID_FILE}")
        if ps -p "${PID}" > /dev/null 2>&1; then
            echo "‚úÖ el servicio est√° corriendo (pid: ${PID})"

            # mostramos informaci√≥n del proceso
            ps -p "${PID}" -o pid,ppid,user,%cpu,%mem,etime,cmd

            # prueba de conexi√≥n
            echo ""
            echo "üîç probando la conexi√≥n..."
            cd "${PROJECT_DIR}"
            export PYTHONPATH="${PROJECT_DIR}/src"
            PING_RESULT=$("${VENV_PYTHON}" -c "import asyncio; from v2m.client import send_command; print(asyncio.run(send_command('PING')))" 2>&1)

            if echo "${PING_RESULT}" | grep -q "PONG"; then
                echo "‚úÖ el servicio responde correctamente"
            else
                echo "‚ö†Ô∏è  el servicio no responde al ping"
                echo "${PING_RESULT}"
            fi

            return 0
        else
            echo "‚ùå existe el archivo pid pero el proceso no est√° corriendo"
            rm -f "${PID_FILE}"
            return 1
        fi
    else
        echo "‚ùå el servicio no est√° corriendo no encontr√© el archivo pid"
        return 1
    fi
}

show_logs() {
    if [ ! -f "${LOG_FILE}" ]; then
        echo "‚ùå no encontr√© el archivo de registros: ${LOG_FILE}"
        return 1
    fi

    if command -v less > /dev/null 2>&1; then
        less +G "${LOG_FILE}"
    else
        tail -50 "${LOG_FILE}"
    fi
}

# --- PRINCIPAL ---
case "${1:-}" in
    start)
        start_daemon
        ;;
    stop)
        stop_daemon
        ;;
    restart)
        stop_daemon
        sleep 1
        start_daemon
        ;;
    status)
        status_daemon
        ;;
    logs)
        show_logs
        ;;
    *)
        echo "uso: $0 {start|stop|restart|status|logs}"
        echo ""
        echo "COMANDOS:"
        echo "  start    - inicia el servicio"
        echo "  stop     - detiene el servicio"
        echo "  restart  - reinicia el servicio"
        echo "  status   - muestra el estado del servicio"
        echo "  logs     - muestra los registros del servicio"
        exit 1
        ;;
esac
===
#!/bin/bash

# This file is part of voice2machine.
#
# voice2machine is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# voice2machine is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with voice2machine.  If not, see <https://www.gnu.org/licenses/>.
#
# v2m-daemon.sh - script para gestionar el servicio voice2machine
#
# DESCRIPCI√ìN
#   este script te permite controlar el servicio de v2m que se ejecuta
#   en segundo plano puedes iniciarlo detenerlo reiniciarlo y
#   verificar si todo est√° funcionando bien
#
# USO
#   ./scripts/v2m-daemon.sh [start|stop|restart|status|logs]
#
# COMANDOS
#   start    - inicia el servicio en segundo plano
#   stop     - detiene el servicio de forma segura
#   restart  - reinicia el servicio primero lo detiene y luego lo inicia
#   status   - te muestra el estado actual y prueba la conexi√≥n
#   logs     - te muestra los registros del servicio
#
# ARCHIVOS
#   /tmp/v2m_daemon.log  - archivo donde se guardan los registros
#   /tmp/v2m_daemon.pid  - archivo que guarda el identificador del proceso
#
# VARIABLES DE ENTORNO
#   LD_LIBRARY_PATH - se configura sola para que funcione con cuda
#   PYTHONPATH      - se configura para incluir el c√≥digo fuente
#
# DEPENDENCIAS
#   - python 3.12+ con entorno virtual en ./venv
#   - librer√≠as de nvidia en el entorno virtual opcional para gpu
#
# EJEMPLOS
#   # iniciar el servicio
#   ./scripts/v2m-daemon.sh start
#
#   # ver c√≥mo est√° todo y probar la conexi√≥n
#   ./scripts/v2m-daemon.sh status
#
#   # ver qu√© est√° pasando en tiempo real
#   ./scripts/v2m-daemon.sh logs
#
# NOTAS
#   - el servicio usa un socket unix para comunicarse
#   - los registros se limpian solos autom√°ticamente
#   - si no tienes tarjeta gr√°fica nvidia usar√° el procesador autom√°ticamente
#
# AUTOR
#   equipo voice2machine
#
# DESDE
#   v1.0.0
#

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
PROJECT_DIR="$( dirname "$( dirname "${SCRIPT_DIR}" )" )/apps/backend"
VENV_PYTHON="${PROJECT_DIR}/venv/bin/python"

# --- LOAD COMMON UTILS ---
source "${SCRIPT_DIR}/../utils/common.sh"
RUNTIME_DIR=$(get_runtime_dir)
LOG_FILE="${RUNTIME_DIR}/v2m_daemon.log"
PID_FILE="${RUNTIME_DIR}/v2m_daemon.pid"

start_daemon() {
    if [ -f "${PID_FILE}" ]; then
        PID=$(cat "${PID_FILE}")
        if ps -p "${PID}" > /dev/null 2>&1; then
            echo "‚ùå el servicio ya est√° corriendo (pid: ${PID})"
            return 1
        else
            echo "‚ö†Ô∏è  encontr√© un archivo pid pero el proceso no existe as√≠ que voy a limpiarlo"
            rm -f "${PID_FILE}"
        fi
    fi

    echo "üöÄ iniciando el servicio de v2m..."

    cd "${PROJECT_DIR}"
    export PYTHONPATH="${PROJECT_DIR}/src"

    # --- configurar ld_library_path para cuda y cudnn ---
    # buscamos las librer√≠as de nvidia en el entorno virtual que son
    # necesarias para que whisper funcione con la tarjeta gr√°fica

    # 1. Try to find site-packages dir directly
    VENV_LIB_BASE="${PROJECT_DIR}/venv/lib"
    # Find the first python3.x dir (usually only one)
    PYTHON_LIB_DIR=$(find "$VENV_LIB_BASE" -maxdepth 1 -name "python3.*" -type d | head -n 1)

    if [ -n "$PYTHON_LIB_DIR" ]; then
        VENV_LIB="${PYTHON_LIB_DIR}/site-packages/nvidia"
        CUDA_PATHS=""

        if [ -d "${VENV_LIB}" ]; then
            for lib_path in "${VENV_LIB}"/*/lib; do
                if [ -d "$lib_path" ]; then
                    if [ -z "${CUDA_PATHS}" ]; then
                        CUDA_PATHS="$lib_path"
                    else
                        CUDA_PATHS="${CUDA_PATHS}:${lib_path}"
                    fi
                fi
            done
        fi

        # agregamos las rutas a la variable de entorno
        if [ -n "${CUDA_PATHS}" ]; then
            export LD_LIBRARY_PATH="${CUDA_PATHS}:${LD_LIBRARY_PATH:-}"
            echo "üîß configur√© las librer√≠as de nvidia para usar la tarjeta gr√°fica"
        else
            echo "‚ö†Ô∏è  no encontr√© las librer√≠as de nvidia"
        fi
    fi

    "${VENV_PYTHON}" -m v2m.main --daemon > "${LOG_FILE}" 2>&1 &

    DAEMON_PID=$!
    echo "${DAEMON_PID}" > "${PID_FILE}"

    # Wait for socket to be created (max ~30s for model loading)
    SOCKET_PATH="${RUNTIME_DIR}/v2m.sock"
    WAIT_TIMEOUT=60
    WAITED=0
    while [ ! -S "${SOCKET_PATH}" ] && [ "${WAITED}" -lt "${WAIT_TIMEOUT}" ]; do
        # Check if process died during startup
        if ! ps -p "${DAEMON_PID}" > /dev/null 2>&1; then
            echo "‚ùå el proceso muri√≥ durante el arranque"
            tail -20 "${LOG_FILE}"
            rm -f "${PID_FILE}"
            return 1
        fi
        sleep 0.5
        WAITED=$((WAITED + 1))
    done

    if [ ! -S "${SOCKET_PATH}" ]; then
        echo "‚ö†Ô∏è  el socket no apareci√≥ despu√©s de ${WAIT_TIMEOUT}s"
    fi

    if ps -p "${DAEMON_PID}" > /dev/null 2>&1; then
        echo "‚úÖ el servicio arranc√≥ correctamente (pid: ${DAEMON_PID})"
        echo "üìã puedes ver los registros en: ${LOG_FILE}"
    else
        echo "‚ùå hubo un problema al iniciar el servicio revisa los registros"
        tail -20 "${LOG_FILE}"
        rm -f "${PID_FILE}"
        return 1
    fi
}

stop_daemon() {
    if [ ! -f "${PID_FILE}" ]; then
        echo "‚ö†Ô∏è  no encontr√© el archivo pid as√≠ que buscar√© el proceso manualmente"
        PID=$(ps aux | grep "python.*v2m.main --daemon" | grep -v grep | awk '{print $2}' | head -1)
        if [ -z "${PID}" ]; then
            echo "‚ùå el servicio no est√° corriendo"
            return 1
        fi
    else
        PID=$(cat "${PID_FILE}")
    fi

    echo "üõë deteniendo el servicio (pid: ${PID})..."
    kill -TERM "${PID}" 2>/dev/null

    # esperamos hasta 5 segundos para que termine ordenadamente
    for i in {1..10}; do
        if ! ps -p "${PID}" > /dev/null 2>&1; then
            echo "‚úÖ servicio detenido correctamente"
            rm -f "${PID_FILE}"
            return 0
        fi
        sleep 0.5
    done

    # si no termin√≥ lo forzamos
    echo "‚ö†Ô∏è  el servicio no respondi√≥ as√≠ que lo voy a forzar"
    kill -9 "${PID}" 2>/dev/null
    rm -f "${PID_FILE}"
    echo "‚úÖ servicio detenido forzadamente"
}

status_daemon() {
    if [ -f "${PID_FILE}" ]; then
        PID=$(cat "${PID_FILE}")
        if ps -p "${PID}" > /dev/null 2>&1; then
            echo "‚úÖ el servicio est√° corriendo (pid: ${PID})"

            # mostramos informaci√≥n del proceso
            ps -p "${PID}" -o pid,ppid,user,%cpu,%mem,etime,cmd

            # prueba de conexi√≥n
            echo ""
            echo "üîç probando la conexi√≥n..."
            cd "${PROJECT_DIR}"
            export PYTHONPATH="${PROJECT_DIR}/src"
            PING_RESULT=$("${VENV_PYTHON}" -c "import asyncio; from v2m.client import send_command; print(asyncio.run(send_command('PING')))" 2>&1)

            if echo "${PING_RESULT}" | grep -q "PONG"; then
                echo "‚úÖ el servicio responde correctamente"
            else
                echo "‚ö†Ô∏è  el servicio no responde al ping"
                echo "${PING_RESULT}"
            fi

            return 0
        else
            echo "‚ùå existe el archivo pid pero el proceso no est√° corriendo"
            rm -f "${PID_FILE}"
            return 1
        fi
    else
        echo "‚ùå el servicio no est√° corriendo no encontr√© el archivo pid"
        return 1
    fi
}

show_logs() {
    if [ ! -f "${LOG_FILE}" ]; then
        echo "‚ùå no encontr√© el archivo de registros: ${LOG_FILE}"
        return 1
    fi

    if command -v less > /dev/null 2>&1; then
        less +G "${LOG_FILE}"
    else
        tail -50 "${LOG_FILE}"
    fi
}

# --- PRINCIPAL ---
case "${1:-}" in
    start)
        start_daemon
        ;;
    stop)
        stop_daemon
        ;;
    restart)
        stop_daemon
        sleep 1
        start_daemon
        ;;
    status)
        status_daemon
        ;;
    logs)
        show_logs
        ;;
    *)
        echo "uso: $0 {start|stop|restart|status|logs}"
        echo ""
        echo "COMANDOS:"
        echo "  start    - inicia el servicio"
        echo "  stop     - detiene el servicio"
        echo "  restart  - reinicia el servicio"
        echo "  status   - muestra el estado del servicio"
        echo "  logs     - muestra los registros del servicio"
        exit 1
        ;;
esac
```

```diff:v2m-toggle.sh
#!/bin/bash

# This file is part of voice2machine.
#
# voice2machine is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# voice2machine is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with voice2machine.  If not, see <https://www.gnu.org/licenses/>.
#
# v2m-toggle.sh - script para activar o desactivar la grabaci√≥n
#
# DESCRIPCI√ìN
#   este es el script principal para controlar la grabaci√≥n por voz
#   sirve para iniciar y detener la grabaci√≥n y est√° pensado para
#   usarse con un atajo de teclado
#
# USO
#   ./scripts/v2m-toggle.sh
#
# C√ìMO FUNCIONA
#   primera vez que lo ejecutas
#     1 verifica si el servicio est√° corriendo y lo inicia si es necesario
#     2 comienza a grabar el audio
#     3 crea un archivo temporal para recordar que est√° grabando
#
#   segunda vez que lo ejecutas
#     1 se da cuenta de que ya est√° grabando
#     2 detiene la grabaci√≥n
#     3 transcribe el audio a texto
#     4 copia el texto al portapapeles
#     5 elimina el archivo temporal
#
# CONFIGURACI√ìN EN GNOME
#   # crear un atajo personalizado
#   KEYBINDING_PATH="/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/whisper0/"
#   gsettings set org.gnome.settings-daemon.plugins.media-keys custom-keybindings \
#     "['$KEYBINDING_PATH']"
#   gsettings set org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:$KEYBINDING_PATH \
#     name 'v2m toggle'
#   gsettings set org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:$KEYBINDING_PATH \
#     command '$HOME/v2m/scripts/v2m-toggle.sh'
#   gsettings set org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:$KEYBINDING_PATH \
#     binding '<Control><Shift>space'
#
# DEPENDENCIAS
#   - v2m-daemon.sh para controlar el servicio

#   - notify-send para mostrar notificaciones en el escritorio
#   - entorno virtual de python en ./venv
#
# ARCHIVOS
#   /tmp/v2m_recording.pid - indica que se est√° grabando
#
# NOTAS
#   - el servicio arranca solo si no est√° activo
#   - ver√°s notificaciones sobre lo que est√° pasando
#
# AUTOR
#   equipo voice2machine
#
# DESDE
#   v1.0.0
#

# --- CONFIGURACI√ìN ---
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
PROJECT_DIR="$( dirname "$( dirname "${SCRIPT_DIR}" )" )/apps/backend"
NOTIFY_EXPIRE_TIME=3000

# --- LOAD COMMON UTILS ---
source "${SCRIPT_DIR}/../utils/common.sh"
RUNTIME_DIR=$(get_runtime_dir)

# --- RUTAS DERIVADAS ---
VENV_PATH="${PROJECT_DIR}/venv"
MAIN_SCRIPT="${PROJECT_DIR}/src/v2m/main.py"
RECORDING_FLAG="${RUNTIME_DIR}/v2m_recording.pid"
DAEMON_SCRIPT="${SCRIPT_DIR}/v2m-daemon.sh"

# --- FUNCI√ìN PRINCIPAL ---
# --- FUNCI√ìN PRINCIPAL ---
ensure_daemon() {
    "${DAEMON_SCRIPT}" status > /dev/null 2>&1
    if [ $? -ne 0 ]; then
        if command -v notify-send > /dev/null 2>&1; then
            notify-send --expire-time=${NOTIFY_EXPIRE_TIME} "üéôÔ∏è v2m" "iniciando el servicio en segundo plano"
        fi

        "${DAEMON_SCRIPT}" start
        if [ $? -ne 0 ]; then
            if command -v notify-send > /dev/null 2>&1; then
                notify-send --expire-time=${NOTIFY_EXPIRE_TIME} "‚ùå error de v2m" "no pude iniciar el servicio"
            fi
            exit 1
        fi
        # Esperar un momento a que el daemon est√© listo
        sleep 2
    fi
}

run_client() {
    local command=$1
    local payload="${2:-}"

    # Check if standalone client exists
    local CLIENT_SCRIPT="${SCRIPT_DIR}/../utils/send_command.py"
    if [ -f "$CLIENT_SCRIPT" ]; then
        python3 "$CLIENT_SCRIPT" "$command" "$payload"
    else
        # Fallback to slower full module method
        if [ ! -f "${VENV_PATH}/bin/activate" ]; then
            if command -v notify-send > /dev/null 2>&1; then
                notify-send --expire-time=${NOTIFY_EXPIRE_TIME} "‚ùå error de v2m" "no encontr√© el entorno virtual en ${VENV_PATH}"
            fi
            exit 1
        fi
        source "${VENV_PATH}/bin/activate"
        export PYTHONPATH="${PROJECT_DIR}/src"
        python3 -m v2m.client "${command}" ${payload}
    fi
}

# --- L√ìGICA DE CONMUTACI√ìN ---
ensure_daemon

# Consultar estado real al daemon (IPC) en lugar de confiar en archivo PID
STATUS_OUTPUT=$(run_client "GET_STATUS")

if [[ "$STATUS_OUTPUT" == *"STATUS: recording"* ]]; then
    # Si est√° grabando, detener
    run_client "STOP_RECORDING"
elif [[ "$STATUS_OUTPUT" == *"STATUS: idle"* ]] || [[ "$STATUS_OUTPUT" == *"STATUS: paused"* ]]; then
    # Si est√° inactivo o pausado, iniciar
    run_client "START_RECORDING"
else
    # Estado desconocido o error, intentar iniciar por defecto
    if command -v notify-send > /dev/null 2>&1; then
        notify-send --expire-time=${NOTIFY_EXPIRE_TIME} "‚ö†Ô∏è estado desconocido" "intentando grabar..."
    fi
    run_client "START_RECORDING"
fi
===
#!/bin/bash

# This file is part of voice2machine.
#
# voice2machine is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# voice2machine is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with voice2machine.  If not, see <https://www.gnu.org/licenses/>.
#
# v2m-toggle.sh - script para activar o desactivar la grabaci√≥n
#
# DESCRIPCI√ìN
#   este es el script principal para controlar la grabaci√≥n por voz
#   sirve para iniciar y detener la grabaci√≥n y est√° pensado para
#   usarse con un atajo de teclado
#
# USO
#   ./scripts/v2m-toggle.sh
#
# C√ìMO FUNCIONA
#   primera vez que lo ejecutas
#     1 verifica si el servicio est√° corriendo y lo inicia si es necesario
#     2 comienza a grabar el audio
#     3 crea un archivo temporal para recordar que est√° grabando
#
#   segunda vez que lo ejecutas
#     1 se da cuenta de que ya est√° grabando
#     2 detiene la grabaci√≥n
#     3 transcribe el audio a texto
#     4 copia el texto al portapapeles
#     5 elimina el archivo temporal
#
# CONFIGURACI√ìN EN GNOME
#   # crear un atajo personalizado
#   KEYBINDING_PATH="/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/whisper0/"
#   gsettings set org.gnome.settings-daemon.plugins.media-keys custom-keybindings \
#     "['$KEYBINDING_PATH']"
#   gsettings set org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:$KEYBINDING_PATH \
#     name 'v2m toggle'
#   gsettings set org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:$KEYBINDING_PATH \
#     command '$HOME/v2m/scripts/v2m-toggle.sh'
#   gsettings set org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:$KEYBINDING_PATH \
#     binding '<Control><Shift>space'
#
# DEPENDENCIAS
#   - v2m-daemon.sh para controlar el servicio

#   - notify-send para mostrar notificaciones en el escritorio
#   - entorno virtual de python en ./venv
#
# ARCHIVOS
#   /tmp/v2m_recording.pid - indica que se est√° grabando
#
# NOTAS
#   - el servicio arranca solo si no est√° activo
#   - ver√°s notificaciones sobre lo que est√° pasando
#
# AUTOR
#   equipo voice2machine
#
# DESDE
#   v1.0.0
#

# --- CONFIGURACI√ìN ---
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
PROJECT_DIR="$( dirname "$( dirname "${SCRIPT_DIR}" )" )/apps/backend"
NOTIFY_EXPIRE_TIME=3000

# --- LOAD COMMON UTILS ---
source "${SCRIPT_DIR}/../utils/common.sh"
RUNTIME_DIR=$(get_runtime_dir)

# --- RUTAS DERIVADAS ---
VENV_PATH="${PROJECT_DIR}/venv"
MAIN_SCRIPT="${PROJECT_DIR}/src/v2m/main.py"
RECORDING_FLAG="${RUNTIME_DIR}/v2m_recording.pid"
DAEMON_SCRIPT="${SCRIPT_DIR}/v2m-daemon.sh"

# --- FUNCI√ìN PRINCIPAL ---
# --- FUNCI√ìN PRINCIPAL ---
ensure_daemon() {
    "${DAEMON_SCRIPT}" status > /dev/null 2>&1
    if [ $? -ne 0 ]; then
        if command -v notify-send > /dev/null 2>&1; then
            notify-send --expire-time=${NOTIFY_EXPIRE_TIME} "üéôÔ∏è v2m" "iniciando el servicio en segundo plano"
        fi

        "${DAEMON_SCRIPT}" start
        if [ $? -ne 0 ]; then
            if command -v notify-send > /dev/null 2>&1; then
                notify-send --expire-time=${NOTIFY_EXPIRE_TIME} "‚ùå error de v2m" "no pude iniciar el servicio"
            fi
            exit 1
        fi
        # Wait for socket to be ready (model loading can take 30s+)
        SOCKET_PATH="${RUNTIME_DIR}/v2m.sock"
        WAIT_TIMEOUT=60
        WAITED=0
        while [ ! -S "${SOCKET_PATH}" ] && [ "${WAITED}" -lt "${WAIT_TIMEOUT}" ]; do
            sleep 0.5
            WAITED=$((WAITED + 1))
        done
    fi
}

run_client() {
    local command=$1
    local payload="${2:-}"

    # Check if standalone client exists
    local CLIENT_SCRIPT="${SCRIPT_DIR}/../utils/send_command.py"
    if [ -f "$CLIENT_SCRIPT" ]; then
        python3 "$CLIENT_SCRIPT" "$command" "$payload"
    else
        # Fallback to slower full module method
        if [ ! -f "${VENV_PATH}/bin/activate" ]; then
            if command -v notify-send > /dev/null 2>&1; then
                notify-send --expire-time=${NOTIFY_EXPIRE_TIME} "‚ùå error de v2m" "no encontr√© el entorno virtual en ${VENV_PATH}"
            fi
            exit 1
        fi
        source "${VENV_PATH}/bin/activate"
        export PYTHONPATH="${PROJECT_DIR}/src"
        python3 -m v2m.client "${command}" ${payload}
    fi
}

# --- L√ìGICA DE CONMUTACI√ìN ---
ensure_daemon

# Consultar estado real al daemon (IPC) en lugar de confiar en archivo PID
STATUS_OUTPUT=$(run_client "GET_STATUS")

if [[ "$STATUS_OUTPUT" == *"STATUS: recording"* ]]; then
    # Si est√° grabando, detener
    run_client "STOP_RECORDING"
elif [[ "$STATUS_OUTPUT" == *"STATUS: idle"* ]] || [[ "$STATUS_OUTPUT" == *"STATUS: paused"* ]]; then
    # Si est√° inactivo o pausado, iniciar
    run_client "START_RECORDING"
else
    # Estado desconocido o error, intentar iniciar por defecto
    if command -v notify-send > /dev/null 2>&1; then
        notify-send --expire-time=${NOTIFY_EXPIRE_TIME} "‚ö†Ô∏è estado desconocido" "intentando grabar..."
    fi
    run_client "START_RECORDING"
fi
```

---

## Verification Results

```
‚úÖ el servicio est√° corriendo (pid: 182649)
üîç probando la conexi√≥n...
‚úÖ el servicio responde correctamente
```

The standalone client now correctly connects:
```json
{"status": "success", "data": {"state": "idle", "telemetry": {...}}, "error": null}
```
